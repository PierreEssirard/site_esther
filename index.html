<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Esther Marty â€” Portfolio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Helvetica Neue', Arial, sans-serif; background: #000; color: #1a1a1a; line-height: 1.6; overflow-x: hidden; }
        .hero-section { position: relative; width: 100%; height: 100vh; background: #000; display: flex; align-items: center; justify-content: space-between; overflow: hidden; padding: 0 5rem; }
        #canvas3d { position: absolute; left: 0; top: 0; width: 100%; height: 100%; display: block; }
        .hero-content { position: relative; z-index: 10; margin-left: auto; width: 40%; padding-left: 3rem; text-align: left; }
        .hero-content h1 { font-size: 6rem; font-weight: 200; letter-spacing: -2px; margin-bottom: 2rem; color: #fff; line-height: 0.9; opacity: 0; transform: translateX(100px); animation: slideInRight 1.2s cubic-bezier(0.16, 1, 0.3, 1) forwards 0.3s; }
        .hero-content .name-first { display: block; font-size: 5rem; font-weight: 300; margin-bottom: 0.2rem; }
        .hero-content .name-last { display: block; font-size: 7rem; font-weight: 100; letter-spacing: -4px; }
        .hero-content p { font-size: 1.1rem; font-weight: 300; letter-spacing: 3px; text-transform: uppercase; color: rgba(255, 255, 255, 0.7); opacity: 0; transform: translateX(100px); animation: slideInRight 1.2s cubic-bezier(0.16, 1, 0.3, 1) forwards 0.6s; margin-bottom: 3rem; }
        .hero-lines { display: flex; flex-direction: column; gap: 1rem; opacity: 0; transform: translateX(100px); animation: slideInRight 1.2s cubic-bezier(0.16, 1, 0.3, 1) forwards 0.9s; }
        .hero-line { height: 1px; background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.5) 50%, rgba(255,255,255,0) 100%); width: 0; animation: lineExpand 1.5s cubic-bezier(0.16, 1, 0.3, 1) forwards 1.2s; }
        .hero-line:nth-child(2) { animation-delay: 1.4s; }
        .hero-line:nth-child(3) { animation-delay: 1.6s; }
        @keyframes slideInRight { to { opacity: 1; transform: translateX(0); } }
        @keyframes lineExpand { to { width: 100%; } }
        .scroll-indicator { position: absolute; bottom: 3rem; right: 5rem; color: #fff; font-size: 0.8rem; letter-spacing: 3px; opacity: 0; writing-mode: vertical-rl; text-orientation: mixed; animation: fadeIn 1s ease forwards 2s; }
        .scroll-indicator::before { content: ''; display: block; width: 1px; height: 60px; background: linear-gradient(180deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.8) 100%); margin: 0 auto 1rem; animation: scrollLine 2s ease infinite 2.5s; }
        @keyframes scrollLine { 0%, 100% { transform: translateY(0); opacity: 1; } 50% { transform: translateY(20px); opacity: 0.3; } }
        header { position: fixed; top: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); padding: 1.5rem 3rem; display: flex; justify-content: space-between; align-items: center; z-index: 100; border-bottom: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.3s ease; }
        header.scrolled { background: rgba(250, 250, 250, 0.95); border-bottom: 1px solid rgba(0, 0, 0, 0.1); }
        header.scrolled .logo, header.scrolled .school, header.scrolled .admin-btn { color: #1a1a1a; }
        header.scrolled .admin-btn { border-color: #1a1a1a; }
        .logo { font-size: 1rem; font-weight: 300; letter-spacing: 2px; color: #fff; transition: color 0.3s ease; }
        .header-right { display: flex; align-items: center; gap: 2rem; }
        .school { font-size: 0.8rem; color: rgba(255, 255, 255, 0.6); font-weight: 300; letter-spacing: 1px; transition: color 0.3s ease; }
        .admin-btn { background: transparent; border: 1px solid rgba(255, 255, 255, 0.3); color: #fff; padding: 0.5rem 1rem; font-size: 0.75rem; cursor: pointer; transition: all 0.3s ease; letter-spacing: 1px; font-weight: 300; }
        .admin-btn:hover { background: #fff; color: #000; border-color: #fff; }
        header.scrolled .admin-btn:hover { background: #1a1a1a; color: #fff; }
        .projects-section { background: #eac0e1; min-height: 100vh; padding-top: 100px; }
        .projects-intro { max-width: 1600px; margin: 0 auto; padding: 3rem; opacity: 0; transform: translateY(50px); transition: all 0.8s ease; }
        .projects-intro.visible { opacity: 1; transform: translateY(0); }
        .projects-intro h2 { font-size: 2.5rem; font-weight: 300; letter-spacing: -0.5px; margin-bottom: 1rem; color: #1a1a1a; }
        .projects-intro p { font-size: 1rem; color: #666; font-weight: 300; }
        .gallery { max-width: 1600px; margin: 0 auto; padding: 2rem 3rem 4rem; display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 2rem; }
        .empty-state { grid-column: 1 / -1; text-align: center; padding: 6rem 2rem; color: #999; font-size: 1rem; font-weight: 300; }
        @keyframes fadeIn { to { opacity: 1; } }
        @media (max-width: 900px) {
            .hero-section { flex-direction: column; align-items: center; justify-content: flex-start; padding: 2rem; height: auto; }
            #canvas3d { position: relative; width: 100%; height: 50vh; }
            .hero-content { width: 100%; padding-left: 0; margin: 1rem 0 2rem 0; text-align: center; }
            .hero-content h1 { font-size: 3.2rem; }
            .hero-content .name-first { font-size: 2.4rem; }
            .hero-content .name-last { font-size: 3.2rem; }
        }
    </style>
</head>
<body>
    <header id="header">
        <div class="logo">EM</div>
        <div class="header-right">
            <div class="school">Ã‰COLE ESTIENNE Â· PARIS</div>
            <button class="admin-btn">ADMIN</button>
        </div>
    </header>

    <section class="hero-section">
        <canvas id="canvas3d"></canvas>
        <div class="hero-content">
            <h1>
                <span class="name-first">Esther</span>
                <span class="name-last">Marty</span>
            </h1>
            <p>Graphisme & Design</p>
            <div class="hero-lines">
                <div class="hero-line"></div>
                <div class="hero-line"></div>
                <div class="hero-line"></div>
            </div>
        </div>
        <div class="scroll-indicator">SCROLL</div>
    </section>

    <section class="projects-section">
        <div class="projects-intro" id="projectsIntro">
            <h2>Projets</h2>
            <p>Travaux rÃ©alisÃ©s Ã  l'Ã‰cole Estienne, Paris</p>
        </div>
        <div class="gallery" id="gallery">
            <div class="empty-state">Aucun projet pour le moment</div>
        </div>
    </section>

    <script>
        const canvas = document.getElementById('canvas3d');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        
        function setRendererToCanvasSize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            renderer.setSize(width, height, false);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }

        renderer.setClearColor(0x000000, 1);

        const ambientLight = new THREE.AmbientLight(0xf0c4df, 0.3);
        scene.add(ambientLight);
        const light1 = new THREE.DirectionalLight(0xf0c4df, 3.0);
        light1.position.set(5, 5, 5);
        scene.add(light1);
        const light2 = new THREE.DirectionalLight(0xf0c4df, 2.8);
        light2.position.set(-5, 3, -5);
        scene.add(light2);

        const model = new THREE.Group();
        const radius = 2.5;
        const circlePoints = [];
        const segments = 60;
        
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            circlePoints.push(new THREE.Vector3(Math.cos(angle) * radius, Math.sin(angle) * radius, 0));
        }
        
        const circleCurve = new THREE.CatmullRomCurve3(circlePoints, true);
        const railGeo = new THREE.TubeGeometry(circleCurve, 120, 0.08, 16, true);
        const rail = new THREE.Mesh(railGeo, new THREE.MeshBasicMaterial({ color: 0xf0c4df }));
        model.add(rail);
        
        const railInner = new THREE.Mesh(new THREE.TubeGeometry(circleCurve, 120, 0.04, 12, true), new THREE.MeshBasicMaterial({ color: 0xf0c4df, transparent: true, opacity: 0.7 }));
        railInner.scale.set(0.95, 0.95, 1);
        model.add(railInner);
        
        const wagonGroup = new THREE.Group();
        const numWagons = 8;
        
        for (let i = 0; i < numWagons; i++) {
            const wagonContainer = new THREE.Group();
            const wagon = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.35, 0.35), new THREE.MeshBasicMaterial({ color: 0xa8d0ff }));
            wagonContainer.add(wagon);
            
            const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.08, 0.36), new THREE.MeshBasicMaterial({ color: i % 3 === 0 ? 0xa8c9e8 : i % 3 === 1 ? 0xb8d4f0 : 0xc8def5, transparent: true, opacity: 0.95 }));
            stripe.position.y = 0.1;
            wagonContainer.add(stripe);
            
            const windowGeo = new THREE.PlaneGeometry(0.12, 0.12);
            const windowMat = new THREE.MeshBasicMaterial({ color: 0xfff1a8, transparent: true, opacity: 0.75 });
            for (let j = 0; j < 3; j++) {
                const win = new THREE.Mesh(windowGeo, windowMat);
                win.position.set((j - 1) * 0.15, 0, 0.181);
                wagonContainer.add(win);
                const winBack = win.clone();
                winBack.position.z = -0.181;
                winBack.rotation.y = Math.PI;
                wagonContainer.add(winBack);
            }
            
            const roof = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.03, 0.36), new THREE.MeshBasicMaterial({ color: 0xfff1a8 }));
            roof.position.y = 0.19;
            wagonContainer.add(roof);

            const wheelGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.04, 12);
            const wheelMat = new THREE.MeshBasicMaterial({ color: 0xfff1a8 });
            for (let w = 0; w < 4; w++) {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(w < 2 ? -0.16 : 0.16, -0.18, w % 2 === 0 ? 0.12 : -0.12);
                wagonContainer.add(wheel);
            }

            wagonContainer.userData.offset = i / numWagons;
            wagonGroup.add(wagonContainer);
        }
        model.add(wagonGroup);
        model.position.set(-5, 0, 0); // DÃ©placer tout le modÃ¨le Ã  gauche
        scene.add(model);

        function adjustCameraForScreen() {
            const w = window.innerWidth;
            if (w <= 480) {
                camera.position.set(0, 0, 5);
                model.scale.set(0.85, 0.85, 0.85);
            } else if (w <= 900) {
                camera.position.set(0, 0, 5.5);
                model.scale.set(0.95, 0.95, 0.95);
            } else {
                camera.position.set(0, 0, 7);
                model.scale.set(1, 1, 1);
            }
        }

        function ensureRendererReady(retries = 0) {
            if (retries < 20) {
                setTimeout(() => ensureRendererReady(retries + 1), 150);
                return;
            }
            setRendererToCanvasSize();
            adjustCameraForScreen();
        }

        window.addEventListener('load', () => ensureRendererReady());
        window.addEventListener('resize', () => { setRendererToCanvasSize(); adjustCameraForScreen(); });

        let trainProgress = 0;
        const trainSpeedSlow = 0.0008;
        const trainSpeedFast = 0.01;
        let currentSpeed = trainSpeedSlow;
        let isHovering = false;
        let fastLapCount = 0;
        let hasExploded = false;
        let particles = [];
        let haussmannBuilding = null;
        let wasInFastMode = false;
        let lapStarted = false;

        canvas.addEventListener('mouseenter', () => { isHovering = true; });
        canvas.addEventListener('mouseleave', () => { isHovering = false; });

        function createHaussmannBuilding() {
            const sculpture = new THREE.Group();
            
            // Chemin de vie en spirale ascendante - symbolise l'Ã©volution personnelle
            const spiralPoints = [];
            const turns = 3;
            const height = 4;
            const radiusBase = 1.5;
            
            for (let i = 0; i <= 100; i++) {
                const t = i / 100;
                const angle = t * Math.PI * 2 * turns;
                const r = radiusBase * (1 - t * 0.3);
                const y = t * height - height / 2;
                spiralPoints.push(new THREE.Vector3(
                    Math.cos(angle) * r,
                    y,
                    Math.sin(angle) * r
                ));
            }
            
            const spiralCurve = new THREE.CatmullRomCurve3(spiralPoints);
            const spiralPath = new THREE.Mesh(
                new THREE.TubeGeometry(spiralCurve, 100, 0.08, 8, false),
                new THREE.MeshBasicMaterial({ color: 0xfff1a8, transparent: true, opacity: 0.9 })
            );
            sculpture.add(spiralPath);
            
            // SphÃ¨res le long du chemin - moments clÃ©s de la vie
            for (let i = 0; i <= 10; i++) {
                const t = i / 10;
                const point = spiralCurve.getPoint(t);
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15 + Math.sin(i) * 0.05, 16, 16),
                    new THREE.MeshBasicMaterial({ 
                        color: i % 3 === 0 ? 0xa8d0ff : i % 3 === 1 ? 0xf0c4df : 0xfff1a8,
                        transparent: true,
                        opacity: 0.85
                    })
                );
                sphere.position.copy(point);
                sculpture.add(sphere);
            }
            
            // Base - le commencement
            const baseRing = new THREE.Mesh(
                new THREE.TorusGeometry(1.8, 0.12, 16, 32),
                new THREE.MeshBasicMaterial({ color: 0xb8d4f0, transparent: true, opacity: 0.7 })
            );
            baseRing.position.y = -height / 2 - 0.3;
            baseRing.rotation.x = Math.PI / 2;
            sculpture.add(baseRing);
            
            // Sommet - l'accomplissement (fleur Ã©panouie)
            const petalCount = 8;
            for (let i = 0; i < petalCount; i++) {
                const angle = (i / petalCount) * Math.PI * 2;
                const petal = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.15, 0.08),
                    new THREE.MeshBasicMaterial({ 
                        color: i % 2 === 0 ? 0xf0c4df : 0xeac0e1,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                petal.position.set(
                    Math.cos(angle) * 0.5,
                    height / 2 + 0.3,
                    Math.sin(angle) * 0.5
                );
                petal.rotation.y = angle;
                petal.rotation.z = Math.PI / 6;
                sculpture.add(petal);
            }
            
            // Centre de la fleur
            const flowerCenter = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xfff1a8 })
            );
            flowerCenter.position.y = height / 2 + 0.3;
            sculpture.add(flowerCenter);
            
            // Particules flottantes autour - rÃªves et aspirations
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 2 + Math.random() * 1;
                const yPos = (Math.random() - 0.5) * height;
                
                const particle = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.08, 0.08),
                    new THREE.MeshBasicMaterial({ 
                        color: [0xa8d0ff, 0xf0c4df, 0xfff1a8][Math.floor(Math.random() * 3)],
                        transparent: true,
                        opacity: 0.6
                    })
                );
                particle.position.set(
                    Math.cos(angle) * distance,
                    yPos,
                    Math.sin(angle) * distance
                );
                particle.userData.orbitSpeed = 0.001 + Math.random() * 0.002;
                particle.userData.orbitRadius = distance;
                particle.userData.orbitAngle = angle;
                particle.userData.yBase = yPos;
                sculpture.add(particle);
                sculpture.userData.orbitingParticles = sculpture.userData.orbitingParticles || [];
                    sculpture.userData.orbitingParticles.push(particle);
            }
            
            sculpture.position.set(0, 0, 0);
            return sculpture;
        }

        function createParticle(position, velocity) {
            const size = Math.random() * 0.15 + 0.05;
            const colors = [0xa8d0ff, 0xfff1a8, 0xb8d4f0, 0xc8def5, 0xf0c4df, 0xeac0e1, 0xffd4e5];
            const particle = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)] }));
            particle.position.copy(position);
            particle.userData.velocity = velocity;
            particle.userData.rotation = new THREE.Vector3((Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2);
            return particle;
        }

        function explodeTrain() {
            hasExploded = true;
            wagonGroup.children.forEach(wagon => {
                const pos = wagon.position.clone();
                for (let i = 0; i < 60; i++) {
                    // VÃ©locitÃ© MASSIVE pour atteindre absolument TOUS les coins
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 8
                    );
                    const particle = createParticle(pos, velocity);
                    particles.push(particle);
                    scene.add(particle);
                }
            });
            
            // BEAUCOUP plus de particules depuis le centre avec vitesse extrÃªme
            for (let i = 0; i < 300; i++) {
                const centerPos = new THREE.Vector3(0, 0, 0);
                const angle = (i / 300) * Math.PI * 2;
                const elevation = (Math.random() - 0.5) * Math.PI;
                const speed = 3 + Math.random() * 6; // Vitesse TRÃˆS augmentÃ©e
                
                const velocity = new THREE.Vector3(
                    Math.cos(angle) * Math.cos(elevation) * speed,
                    Math.sin(elevation) * speed,
                    Math.sin(angle) * Math.cos(elevation) * speed
                );
                
                const particle = createParticle(centerPos, velocity);
                particles.push(particle);
                scene.add(particle);
            }
            
            wagonGroup.visible = false;
            rail.visible = false;
            railInner.visible = false;
            
            setTimeout(() => {
                haussmannBuilding = createHaussmannBuilding();
                haussmannBuilding.position.set(-5, 0, 0); // Positionner Ã  gauche
                scene.add(haussmannBuilding);
                haussmannBuilding.scale.set(0, 0, 0);
                const startTime = Date.now();
                function animateAppear() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / 2000, 1);
                    const eased = 1 - Math.pow(1 - progress, 3);
                    haussmannBuilding.scale.set(eased, eased, eased);
                    if (progress < 1) requestAnimationFrame(animateAppear);
                }
                animateAppear();
            }, 1500);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (!hasExploded) {
                if (isHovering) {
                    currentSpeed += (trainSpeedFast - currentSpeed) * 0.05;
                } else {
                    currentSpeed += (trainSpeedSlow - currentSpeed) * 0.05;
                }
                
                const oldProgress = trainProgress;
                trainProgress = (trainProgress + currentSpeed) % 1;
                
                // DÃ©tecter si on est en mode rapide
                const isInFastMode = currentSpeed > (trainSpeedSlow + trainSpeedFast) / 2;
                
                // Compter un tour quand on passe de ~1 Ã  ~0 en mode rapide
                if (isInFastMode) {
                    if (!lapStarted) {
                        lapStarted = true;
                    }
                    if (oldProgress > 0.9 && trainProgress < 0.1) {
                        fastLapCount++;
                        console.log('ðŸ Tour rapide complÃ©tÃ©:', fastLapCount, '/ 10');
                        if (fastLapCount >= 1.5) {
                            console.log('ðŸ’¥ EXPLOSION !');
                            explodeTrain();
                        }
                    }
                } else {
                    lapStarted = false;
                }

                wagonGroup.children.forEach(wagon => {
                    const t = (trainProgress + wagon.userData.offset) % 1;
                    const pos = circleCurve.getPoint(t);
                    wagon.position.copy(pos);
                    const tangent = circleCurve.getTangent(t);
                    wagon.rotation.z = Math.atan2(tangent.y, tangent.x);
                });

                model.rotation.y = Math.sin(Date.now() * 0.0005) * 0.15;
                model.rotation.x = Math.cos(Date.now() * 0.0003) * 0.08;
            } else {
                particles.forEach((particle, index) => {
                    particle.position.add(particle.userData.velocity);
                    particle.userData.velocity.y -= 0.002; // GravitÃ© encore plus douce
                    // Presque pas de friction pour aller trÃ¨s loin
                    particle.userData.velocity.multiplyScalar(0.995);
                    particle.rotation.x += particle.userData.rotation.x;
                    particle.rotation.y += particle.userData.rotation.y;
                    particle.rotation.z += particle.userData.rotation.z;
                    // Limites Ã‰NORMES pour couvrir absolument tout l'Ã©cran
                    if (particle.position.y < -30 || Math.abs(particle.position.x) > 60 || Math.abs(particle.position.z) > 60) {
                        scene.remove(particle);
                        particles.splice(index, 1);
                    }
                });
                if (haussmannBuilding) {
                    haussmannBuilding.rotation.y += 0.003;
                    
                    // Faire tomber des petits cubes moins frÃ©quemment
                    if (Math.random() < 0.015) { // 1.5% de chance (rÃ©duit de 5%)
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 3 + Math.random() * 2;
                        const colors = [0xa8d0ff, 0xf0c4df, 0xfff1a8, 0xb8d4f0, 0xeac0e1];
                        
                        const fallingCube = new THREE.Mesh(
                            new THREE.BoxGeometry(0.1, 0.1, 0.1),
                            new THREE.MeshBasicMaterial({ 
                                color: colors[Math.floor(Math.random() * colors.length)],
                                transparent: true,
                                opacity: 0.8
                            })
                        );
                        fallingCube.position.set(
                            Math.cos(angle) * distance,
                            3 + Math.random() * 2,
                            Math.sin(angle) * distance
                        );
                        fallingCube.userData.velocity = new THREE.Vector3(0, -0.02, 0);
                        fallingCube.userData.rotation = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1
                        );
                        particles.push(fallingCube);
                        scene.add(fallingCube);
                    }
                    
                    if (haussmannBuilding.userData.orbitingParticles) {
                        haussmannBuilding.userData.orbitingParticles.forEach(p => {
                            p.userData.orbitAngle += p.userData.orbitSpeed;
                            p.position.x = Math.cos(p.userData.orbitAngle) * p.userData.orbitRadius;
                            p.position.z = Math.sin(p.userData.orbitAngle) * p.userData.orbitRadius;
                            p.position.y = p.userData.yBase + Math.sin(Date.now() * 0.001 + p.userData.orbitAngle) * 0.2;
                            p.rotation.x += 0.01;
                            p.rotation.y += 0.01;
                        });
                    }
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('scroll', () => {
            const header = document.getElementById('header');
            if(window.scrollY > 50) header.classList.add('scrolled');
            else header.classList.remove('scrolled');
            const intro = document.getElementById('projectsIntro');
            const rect = intro.getBoundingClientRect();
            if(rect.top < window.innerHeight * 0.8) intro.classList.add('visible');
        });
    </script>
</body>
</html>