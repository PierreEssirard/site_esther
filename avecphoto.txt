// ===== THREE.JS SETUP =====
const canvas = document.getElementById('canvas3d');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000); 

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });

function setRendererToCanvasSize() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(width, height, false);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
}

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);
const light1 = new THREE.DirectionalLight(0xffffff, 1.2);
light1.position.set(5, 5, 5);
scene.add(light1);


// ==========================================================
// 1. GROUPES DE SCÈNE
// ==========================================================
const phase1Group = new THREE.Group();
scene.add(phase1Group);

const phase2Group = new THREE.Group();
scene.add(phase2Group);
phase2Group.visible = false; 


// ==========================================================
// 2. LE TRAIN (PHASE 1)
// ==========================================================
const model = new THREE.Group();
model.position.set(-4.5, 0, 0); // Train calé à gauche
phase1Group.add(model);

const radius = 2.5;
const circlePoints = [];
const segments = 120; 

for (let i = 0; i <= segments; i++) {
    const angle = (i / segments) * Math.PI * 2;
    circlePoints.push(new THREE.Vector3(Math.cos(angle) * radius, Math.sin(angle) * radius, 0));
}

const circleCurve = new THREE.CatmullRomCurve3(circlePoints, true, 'centripetal', 0.5);
const railGeo = new THREE.TubeGeometry(circleCurve, 200, 0.08, 16, true);
const rail = new THREE.Mesh(railGeo, new THREE.MeshBasicMaterial({ color: 0xf0c4df }));
model.add(rail);

const railInner = new THREE.Mesh(
    new THREE.TubeGeometry(circleCurve, 200, 0.04, 12, true), 
    new THREE.MeshBasicMaterial({ color: 0xf0c4df, transparent: true, opacity: 0.7 })
);
railInner.scale.set(0.95, 0.95, 1);
model.add(railInner);

const wagonGroup = new THREE.Group();
const numWagons = 8;

for (let i = 0; i < numWagons; i++) {
    const wagonContainer = new THREE.Group();
    const wagon = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.35, 0.35), new THREE.MeshBasicMaterial({ color: 0xa8d0ff }));
    wagonContainer.add(wagon);
    const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.08, 0.36), new THREE.MeshBasicMaterial({ color: i % 3 === 0 ? 0xa8c9e8 : i % 3 === 1 ? 0xb8d4f0 : 0xc8def5, transparent: true, opacity: 0.95 }));
    stripe.position.y = 0.1;
    wagonContainer.add(stripe);
    
    const wheelGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.04, 16);
    const wheelMat = new THREE.MeshBasicMaterial({ color: 0xfff1a8 }); 
    for (let w = 0; w < 4; w++) {
        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(w < 2 ? -0.16 : 0.16, -0.18, w % 2 === 0 ? 0.12 : -0.12);
        wagonContainer.add(wheel);
    }
    wagonContainer.userData.offset = i / numWagons;
    wagonGroup.add(wagonContainer);
}
model.add(wagonGroup);


// ==========================================================
// 3. VIDÉO PLEIN ÉCRAN ROBUSTE (PHASE 2)
// ==========================================================
const video = document.createElement('video');
video.src = 'animation.mp4'; 
video.crossOrigin = 'anonymous';
video.loop = false;
video.muted = true;
video.playsInline = true;
video.preload = 'auto'; 
video.load(); 

const videoTexture = new THREE.VideoTexture(video);
videoTexture.minFilter = THREE.LinearFilter;
videoTexture.magFilter = THREE.LinearFilter;
videoTexture.format = THREE.RGBFormat;

const videoGeometry = new THREE.PlaneGeometry(1, 1); 
const videoMaterial = new THREE.MeshBasicMaterial({ 
    map: videoTexture, 
    side: THREE.DoubleSide, 
    toneMapped: false
});
const videoScreen = new THREE.Mesh(videoGeometry, videoMaterial);
phase2Group.add(videoScreen);


// ==========================================================
// 4. SCULPTURE & PARTICULES
// ==========================================================
function createHaussmannBuilding() {
    const sculpture = new THREE.Group();
    const colors = [0xa8d0ff, 0xf0c4df, 0xfff1a8]; 
    
    const spiralPoints = [];
    const turns = 3; const height = 5; const radiusBase = 1.5;
    for (let i = 0; i <= 120; i++) {
        const t = i / 120; const angle = t * Math.PI * 2 * turns;
        const r = radiusBase * (1 - t * 0.4); const y = t * height - height / 2;
        spiralPoints.push(new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r));
    }
    const spiralPath = new THREE.Mesh(
        new THREE.TubeGeometry(new THREE.CatmullRomCurve3(spiralPoints), 120, 0.1, 12, false),
        new THREE.MeshBasicMaterial({ color: 0xfff1a8, transparent: true, opacity: 0.9 })
    );
    sculpture.add(spiralPath);
    
    for (let i = 0; i <= 15; i++) {
        const t = i / 15; const point = new THREE.CatmullRomCurve3(spiralPoints).getPoint(t);
        const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), new THREE.MeshBasicMaterial({ color: colors[i % 3], transparent: true, opacity: 0.95 }));
        sphere.position.copy(point); sculpture.add(sphere);
    }
    
    const topPoint = spiralPoints[spiralPoints.length - 1];
    const petalCount = 6;
    for (let i = 0; i < petalCount; i++) {
        const angle = (i / petalCount) * Math.PI * 2;
        const petal = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshBasicMaterial({ color: 0xf0c4df }));
        petal.scale.set(1, 0.2, 0.5); 
        petal.position.set(topPoint.x + Math.cos(angle) * 0.6, topPoint.y, topPoint.z + Math.sin(angle) * 0.6);
        petal.lookAt(topPoint); sculpture.add(petal);
    }
    const flowerCenter = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xa8d0ff }));
    flowerCenter.position.copy(topPoint); sculpture.add(flowerCenter);
    
    sculpture.position.set(-4.5, 0, 0);
    return sculpture;
}

function createFallingCube() {
    const colors = [0xa8d0ff, 0xf0c4df, 0xfff1a8];
    const cube = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.2, 0.2), // Un peu plus gros pour être visible
        new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)], transparent: true, opacity: 0.9 })
    );
    
    const angle = Math.random() * Math.PI * 2;
    const radius = 1 + Math.random() * 3;
    cube.position.set(
        -4.5 + Math.cos(angle) * radius, 
        5, // Commence plus haut
        Math.sin(angle) * radius
    );
    
    cube.userData = {
        velocity: new THREE.Vector3(0, -0.03 - Math.random() * 0.04, 0), // Tombe plus vite
        rotation: new THREE.Vector3(Math.random()*0.1, Math.random()*0.1, Math.random()*0.1)
    };
    return cube;
}

// ==========================================================
// SETUP
// ==========================================================
function adjustCameraForScreen() {
    const w = window.innerWidth;
    if (w <= 480) {
        camera.position.set(0, 0, 7);
        phase1Group.scale.set(1.1, 1.1, 1.1);
        phase1Group.position.set(0, 0, 0);
    } else {
        camera.position.set(-1, 0, 7);
        phase1Group.scale.set(1, 1, 1);
        phase1Group.position.set(0, 0, 0); 
    }
}
setRendererToCanvasSize();
adjustCameraForScreen();
window.addEventListener('resize', () => { setRendererToCanvasSize(); adjustCameraForScreen(); });

// Variables
let trainProgress = 0;
let currentSpeed = 0.0012;
let isAccelerating = false;
let fastLapCount = 0;
let hasExploded = false;
let particles = []; 
let haussmannBuilding = null;
let lapStarted = false;
let currentVideoTime = 0;
let targetVideoTime = 0;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

function updateMousePosition(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
}
function checkTrainIntersection() {
    raycaster.setFromCamera(mouse, camera);
    return raycaster.intersectObjects(wagonGroup.children, true).length > 0;
}

if (!isMobile) {
    canvas.addEventListener('mousemove', (e) => {
        if (hasExploded) return;
        const rect = canvas.getBoundingClientRect();
        const relX = (e.clientX - rect.left) / rect.width;
        const relY = (e.clientY - rect.top) / rect.height;
        if (relX > 0.0 && relX < 0.6 && relY > 0.2 && relY < 0.8) { isAccelerating = true; canvas.style.cursor = 'pointer'; }
        else { isAccelerating = false; canvas.style.cursor = 'default'; }
    });
} else {
    canvas.addEventListener('touchstart', (e) => {
        if (hasExploded) return;
        const touch = e.touches[0];
        updateMousePosition(touch.clientX, touch.clientY);
        if (checkTrainIntersection()) isAccelerating = true;
    });
    canvas.addEventListener('touchend', () => isAccelerating = false);
}

function createParticle(position, velocity) {
    const size = Math.random() * 0.15 + 0.05;
    const colors = [0xa8d0ff, 0xf0c4df, 0xfff1a8];
    const particle = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)] }));
    particle.position.copy(position); particle.userData.velocity = velocity;
    return particle;
}

function explodeTrain() {
    hasExploded = true; isAccelerating = false; canvas.style.cursor = 'default';
    wagonGroup.visible = false; rail.visible = false; railInner.visible = false;
    
    for (let i = 0; i < 150; i++) {
        const v = new THREE.Vector3((Math.random()-0.5)*4, (Math.random()-0.5)*4, (Math.random()-0.5)*4);
        const p = createParticle(new THREE.Vector3(-4.5, 0, 0), v); 
        particles.push(p); phase1Group.add(p);
    }
    
    setTimeout(() => {
        haussmannBuilding = createHaussmannBuilding();
        phase1Group.add(haussmannBuilding);
        haussmannBuilding.scale.set(0, 0, 0);
        let startTime = Date.now();
        function appear() {
            const p = Math.min((Date.now() - startTime) / 1500, 1);
            const s = 1 - Math.pow(1 - p, 3);
            haussmannBuilding.scale.set(s, s, s);
            if (p < 1) requestAnimationFrame(appear);
        }
        appear();
    }, 1000);
}

// ==========================================================
// BOUCLE D'ANIMATION
// ==========================================================
function animate() {
    requestAnimationFrame(animate);
    
    const scrollY = window.scrollY;
    const heroHeight = window.innerHeight;
    const scroll3dSection = document.getElementById('scroll3dSection');
    const heroContent = document.querySelector('.hero-content');

    // Transition Factor : 0 -> 1
    let transitionFactor = Math.max(0, Math.min(1, (scrollY - (heroHeight * 0.1)) / (heroHeight * 0.9)));
    
    // ------------------------
    // PHASE 1 (TRAIN/SCULPTURE)
    // ------------------------
    if (transitionFactor < 1) {
        phase1Group.visible = true;
        const opacity = 1 - transitionFactor;
        
        // Effet parallaxe texte/3D
        const pixelScale = (camera.position.z * Math.tan(THREE.MathUtils.degToRad(camera.fov/2)) * 2) / window.innerHeight;
        phase1Group.position.y = scrollY * pixelScale * 0.9; 

        // Appliquer transparence
        phase1Group.traverse(o => { 
            if(o.material) { o.material.transparent = true; o.material.opacity = opacity; }
        });

        if (!hasExploded) {
            if (isAccelerating) currentSpeed += (0.05 - currentSpeed) * 0.1;
            else currentSpeed += (0.0012 - currentSpeed) * 0.05;
            const oldP = trainProgress; trainProgress = (trainProgress + currentSpeed) % 1;
            if (currentSpeed > 0.025) {
                if (!lapStarted) lapStarted = true;
                if (oldP > 0.9 && trainProgress < 0.1) { fastLapCount++; if (fastLapCount >= 2) explodeTrain(); }
            } else { lapStarted = false; fastLapCount = 0; }
            wagonGroup.children.forEach(w => {
                const t = (trainProgress + w.userData.offset) % 1;
                const pos = circleCurve.getPoint(t); const tan = circleCurve.getTangent(t);
                w.position.copy(pos); w.rotation.z = Math.atan2(tan.y, tan.x);
            });
        } else {
            // Animation Particules
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.position.add(p.userData.velocity); 
                p.userData.velocity.y -= 0.002;
                p.rotation.x += 0.02; p.rotation.y += 0.02;
                if (p.position.y < -10) { phase1Group.remove(p); particles.splice(i, 1); }
            }
            
            if (haussmannBuilding) {
                haussmannBuilding.rotation.y += 0.002;
                // Cubes qui tombent
                if (Math.random() < 0.03) { 
                    const fallingCube = createFallingCube();
                    particles.push(fallingCube);
                    phase1Group.add(fallingCube);
                }
            }
        }
    } else {
        phase1Group.visible = false;
    }

    // ------------------------
    // PHASE 2 (VIDÉO)
    // ------------------------
    if (transitionFactor > 0) {
        phase2Group.visible = true;
        videoMaterial.opacity = transitionFactor;

        // FIX CAMERA: On utilise une caméra fixe pour la vidéo pour éviter les bugs de scaling
        const camDist = 10; // Distance fixe
        camera.position.set(0, 0, camDist);
        camera.lookAt(0, 0, 0);

        // FIX SCALING "COVER": Calcul précis frame par frame
        const vFOV = THREE.MathUtils.degToRad(camera.fov);
        const visibleHeight = 2 * Math.tan(vFOV / 2) * camDist;
        const visibleWidth = visibleHeight * camera.aspect;
        const videoAspect = 16 / 9;
        const screenAspect = visibleWidth / visibleHeight;

        if (screenAspect > videoAspect) {
            videoScreen.scale.set(visibleWidth, visibleWidth / videoAspect, 1);
        } else {
            videoScreen.scale.set(visibleHeight * videoAspect, visibleHeight, 1);
        }

        // LECTURE VIDÉO
        const rect = scroll3dSection.getBoundingClientRect();
        const scrollH = scroll3dSection.offsetHeight - window.innerHeight;
        let p = 0;
        if (scrollH > 0) p = -rect.top / scrollH;
        p = Math.min(1, Math.max(0, p));

        if (video.duration) {
            targetVideoTime = video.duration * p;
            // Inertie très faible pour être réactif (0.5 au lieu de 0.1)
            currentVideoTime += (targetVideoTime - currentVideoTime) * 0.5;
            
            if (Math.abs(targetVideoTime - currentVideoTime) > 0.1) {
                currentVideoTime = targetVideoTime; // Saut direct si trop loin
            }
            if (Math.abs(video.currentTime - currentVideoTime) > 0.02) {
                video.currentTime = currentVideoTime;
            }
        }
    } else {
        phase2Group.visible = false;
        // Si on est purement en phase 1, on remet la caméra de phase 1
        if (transitionFactor === 0) adjustCameraForScreen();
    }
    
    if (heroContent) heroContent.style.opacity = Math.max(0, 1 - transitionFactor * 1.5);

    renderer.render(scene, camera);
}
animate();

window.addEventListener('scroll', () => {
    const h = document.getElementById('header');
    if (window.scrollY > 50) h.classList.add('scrolled');
    else h.classList.remove('scrolled');
    
    const intro = document.getElementById('projectsIntro');
    if (intro && intro.getBoundingClientRect().top < window.innerHeight * 0.8) intro.classList.add('visible');
});

const adminBtn = document.getElementById('adminBtn');
const adminModal = document.getElementById('adminModal');
const closeModal = document.getElementById('closeModal');
if (adminBtn) {
    adminBtn.addEventListener('click', () => adminModal.classList.add('active'));
    closeModal.addEventListener('click', () => adminModal.classList.remove('active'));
}